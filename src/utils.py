import json
from rdkit import Chem
from rdkit.Chem import AllChem
import os
import hashlib
from typing import Tuple, Union
import collections
import itertools
import rdkit
from rdkit import Chem
from rdkit.Chem import AllChem
import re

StoichTuple = collections.namedtuple("StoichTuple", "c_id, stoich")

def ensure_dirs(path):
    if not os.path.exists(path):
        os.makedirs(path)

def sort_x_by_y(x, y, reverse=False):
    yx = list(zip(y, x))
    sorted_yx = sorted(yx, reverse=reverse)
    y, x = list(zip(*sorted_yx))
    return x, y

def save_json(data, save_to):
    with open(save_to, 'w') as f:
        json.dump(data, f)
    
def load_json(path):
    with open(path, 'r') as f:
        data = json.load(f)
    return data

def sanitize(list_of_smiles):
    '''
    Remove stereochem and canonicalize
    a list of smiles
    '''
    sanitized_smiles = []
    for elt in list_of_smiles:
        temp_mol = Chem.MolFromSmiles(elt)
        if temp_mol:
            Chem.rdmolops.RemoveStereochemistry(temp_mol)
            sanitized_smiles.append(Chem.MolToSmiles(temp_mol))
        else:
            sanitized_smiles.append(None)
    return sanitized_smiles

def rxn_entry_to_smarts(rxn_entry):
    '''
    Convert our standard rxn json
    entry into a reaction smarts
    '''
    reactants = sanitize(list(rxn_entry[0].values()))
    products = sanitize(list(rxn_entry[1].values()))
    sma = ".".join(reactants) + ">>" + ".".join(products)
    return sma

def rm_atom_map_num(smarts):
    rxn = AllChem.ReactionFromSmarts(smarts, useSmiles=True)

    # Remove atom map num and write mol smarts in order
    reactant_smas = []   
    for elt in rxn.GetReactants():
        for atom in elt.GetAtoms():
            atom.SetAtomMapNum(0)

        reactant_smas.append(Chem.MolToSmiles(elt))

    product_smas = []
    for elt in rxn.GetProducts():
        for atom in elt.GetAtoms():
            atom.SetAtomMapNum(0)

        product_smas.append(Chem.MolToSmiles(elt))

    unmapped_smarts = '.'.join(reactant_smas) + '>>' + '.'.join(product_smas)
    return unmapped_smarts

def get_compound_hash(
    smi: str, cpd_type: str = "Predicted", inchi_blocks: int = 1
) -> Tuple[str, Union[str, None]]:
    """Create a hash string for a given compound.

    This function generates an unique identifier for a compound, ensuring a
    normalized SMILES. The compound hash is generated by sanitizing and neutralizing the
    SMILES and then generating a hash from the sha1 method in the haslib.

    The hash is prepended with a character depending on the type. Default value is "C":
        1. Coreactant: "X"
        2. Target Compound: "T"
        3. Predicted Compound: "C"

    Parameters
    ----------
    smi : str
        The SMILES of the compound.
    cpd_type : str, optional
        The Compound Type, by default 'Predicted'.

    Returns
    -------
    Tuple[str, Union[str, None]]
        Compound hash, InChI-Key.
    """

    # The ID is generated from a hash of either the InChI key (partial) or SMILES
    # The InChI key is used if the SMILES does not contain '*'
    inchi_key = None

    if "*" not in smi:
        compound = AllChem.MolFromSmiles(smi, sanitize=False)
        try:
            inchi_key = AllChem.MolToInchiKey(compound)
            # Take the first part of the InChIKey as it contains structural
            # information only
            compound = inchi_key.rsplit("-", 3 - inchi_blocks)[0]
        except:
            compound = smi
    else:
        compound = smi

    # Create standard length hash string using hashlib module
    chash = hashlib.sha1(compound.encode("utf-8")).hexdigest()

    # Mark cofactors with an X at the beginning, targets with a T, all else with a C
    if cpd_type == "Coreactant":
        return "X" + chash, compound
    elif cpd_type == "Target Compound":
        return "T" + chash, inchi_key
    else:
        return "C" + chash, inchi_key
    
def get_reaction_hash(reactants, products):
    """Hashes reactant and product lists.

    Generates a unique ID for a given reaction for use in MongoDB.

    Parameters
    ----------
    reactants : List[StoichTuple]
        List of reactants.
    products : List[StoichTuple]
        List of products.

    Returns
    -------
        Reaction hash.
    """
    # Get text reaction to be hashed
    # this is a combination of two functions
    def to_str(half_rxn):
        return [f"({x[1]}) {x[0]}" for x in sorted(half_rxn)]
    reactants.sort()
    products.sort()
    text_ids_rxn = (
        " + ".join(to_str(reactants)) + " => " + " + ".join(to_str(products))
    )
    # Hash text reaction
    rhash = "R" + hashlib.sha256(text_ids_rxn.encode()).hexdigest()

    return rhash


def postsanitize_smiles(smiles_list):
    """Postsanitize smiles after running SMARTS.
    :returns tautomer list of list of smiles"""
    sanitized_list = []
    tautomer_smarts = "[#7H1X3&a:1]:[#6&a:2]:[#7H0X2&a:3]>>[#7H0X2:1]:[#6:2]:[#7H1X3:3]"
    pattern = r'\[\d+\*\]' # Pattern for integer labeled *'s as in rhea
    for s in smiles_list:
        s = re.sub(pattern, '*', s)
        temp_mol = Chem.MolFromSmiles(s, sanitize=False)
        temp_mol = Chem.RemoveHs(temp_mol, sanitize=False)
        aromatic_bonds = [
            i.GetIdx()
            for i in temp_mol.GetBonds()
            if i.GetBondType() == Chem.rdchem.BondType.AROMATIC
        ]
        for i in temp_mol.GetBonds():
            if i.GetBondType() == Chem.rdchem.BondType.UNSPECIFIED:
                i.SetBondType(Chem.rdchem.BondType.SINGLE)
        try:
            Chem.SanitizeMol(temp_mol)
            Chem.rdmolops.RemoveStereochemistry(temp_mol)
            temp_smiles = Chem.MolToSmiles(temp_mol)
        except Exception as msg:
            if "Can't kekulize mol" in str(msg):
                pyrrole_indices = [
                    i[0] for i in temp_mol.GetSubstructMatches(Chem.MolFromSmarts("n"))
                ]
                # indices to sanitize
                for s_i in pyrrole_indices:
                    temp_mol = Chem.MolFromSmiles(s, sanitize=False)
                    if temp_mol.GetAtomWithIdx(s_i).GetNumExplicitHs() == 0:
                        temp_mol.GetAtomWithIdx(s_i).SetNumExplicitHs(1)
                    elif temp_mol.GetAtomWithIdx(s_i).GetNumExplicitHs() == 1:
                        temp_mol.GetAtomWithIdx(s_i).SetNumExplicitHs(0)
                    try:
                        Chem.SanitizeMol(temp_mol)
                        processed_pyrrole_indices = [
                            i[0]
                            for i in temp_mol.GetSubstructMatches(
                                Chem.MolFromSmarts("n")
                            )
                        ]
                        processed_aromatic_bonds = [
                            i.GetIdx()
                            for i in temp_mol.GetBonds()
                            if i.GetBondType() == Chem.rdchem.BondType.AROMATIC
                        ]
                        if (
                            processed_pyrrole_indices != pyrrole_indices
                            or aromatic_bonds != processed_aromatic_bonds
                        ):
                            continue
                        Chem.rdmolops.RemoveStereochemistry(temp_mol)
                        temp_smiles = Chem.MolToSmiles(temp_mol)
                        break
                    except:
                        continue
                if "temp_smiles" not in vars():
                    Chem.rdmolops.RemoveStereochemistry(temp_mol)
                    temp_smiles = Chem.MolToSmiles(temp_mol)
                    sanitized_list.append([temp_smiles])
                    continue
            else:
                Chem.rdmolops.RemoveStereochemistry(temp_mol)
                temp_smiles = Chem.MolToSmiles(temp_mol)
                sanitized_list.append([temp_smiles])
                continue
        rxn = AllChem.ReactionFromSmarts(tautomer_smarts)
        try:
            tautomer_mols = rxn.RunReactants((Chem.MolFromSmiles(temp_smiles),))
        except:
            try:
                tautomer_mols = rxn.RunReactants(
                    (Chem.MolFromSmiles(temp_smiles, sanitize=False),)
                )
            except:
                continue
        tautomer_smiles = [Chem.MolToSmiles(m[0]) for m in tautomer_mols]
        sanitized_list.append(sorted(set(tautomer_smiles + [temp_smiles])))
    return list(itertools.product(*sanitized_list))

_REACTIONS = None # Used in neutralise_charges below (cf. minedatabase.utils)

def neutralise_charges(
    mol: rdkit.Chem.rdchem.Mol, reactions=None
) -> rdkit.Chem.rdchem.Mol:
    """Neutralize all charges in an rdkit mol.

    Parameters
    ----------
    mol : rdkit.Chem.rdchem.Mol
        Molecule to neutralize.
    reactions : list, optional
        patterns to neutralize, by default None.

    Returns
    -------
    mol : rdkit.Chem.rdchem.Mol
        Neutralized molecule.
    """

    def _initialise_neutralisation_reactions():
        patts = (
            # Imidazoles
            ("[n+;H]", "n"),
            # Amines
            ("[N+;!H0]", "N"),
            # Carboxylic acids and alcohols
            ("[$([O-]);!$([O-][#7])]", "O"),
            # Thiols
            ("[S-;X1]", "S"),
            # Sulfonamides
            ("[$([N-;X2]S(=O)=O)]", "N"),
            # Enamines
            ("[$([N-;X2][C,N]=C)]", "N"),
            # Tetrazoles
            ("[n-]", "[nH]"),
            # Sulfoxides
            ("[$([S-]=O)]", "S"),
            # Amides
            ("[$([N-]C=O)]", "N"),
        )
        return [
            (AllChem.MolFromSmarts(x), AllChem.MolFromSmiles(y, False))
            for x, y in patts
        ]

    global _REACTIONS  # pylint: disable=global-statement
    if reactions is None:
        if _REACTIONS is None:
            _REACTIONS = _initialise_neutralisation_reactions()
        reactions = _REACTIONS
    for (reactant, product) in reactions:
        while mol.HasSubstructMatch(reactant):
            rms = AllChem.ReplaceSubstructs(mol, reactant, product)
            mol = rms[0]
    return mol
