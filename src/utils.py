import json
from rdkit import Chem
from rdkit.Chem import AllChem
import os
import hashlib
from typing import List, Tuple, Union
import collections

StoichTuple = collections.namedtuple("StoichTuple", "c_id, stoich")

def ensure_dirs(path):
    if not os.path.exists(path):
        os.makedirs(path)

def sort_x_by_y(x, y, reverse=False):
    yx = list(zip(y, x))
    sorted_yx = sorted(yx, reverse=reverse)
    y, x = list(zip(*sorted_yx))
    return x, y

def save_json(data, save_to):
    with open(save_to, 'w') as f:
        json.dump(data, f)
    
def load_json(path):
    with open(path, 'r') as f:
        data = json.load(f)
    return data

def sanitize(list_of_smiles):
    '''
    Remove stereochem and canonicalize
    a list of smiles
    '''
    sanitized_smiles = []
    for elt in list_of_smiles:
        temp_mol = Chem.MolFromSmiles(elt)
        if temp_mol:
            Chem.rdmolops.RemoveStereochemistry(temp_mol)
            sanitized_smiles.append(Chem.MolToSmiles(temp_mol))
        else:
            sanitized_smiles.append(None)
    return sanitized_smiles

def rxn_entry_to_smarts(rxn_entry):
    '''
    Convert our standard rxn json
    entry into a reaction smarts
    '''
    reactants = sanitize(list(rxn_entry[0].values()))
    products = sanitize(list(rxn_entry[1].values()))
    sma = ".".join(reactants) + ">>" + ".".join(products)
    return sma

def rm_atom_map_num(smarts):
    rxn = AllChem.ReactionFromSmarts(smarts, useSmiles=True)

    # Remove atom map num and write mol smarts in order
    reactant_smas = []   
    for elt in rxn.GetReactants():
        for atom in elt.GetAtoms():
            atom.SetAtomMapNum(0)

        reactant_smas.append(Chem.MolToSmiles(elt))

    product_smas = []
    for elt in rxn.GetProducts():
        for atom in elt.GetAtoms():
            atom.SetAtomMapNum(0)

        product_smas.append(Chem.MolToSmiles(elt))

    unmapped_smarts = '.'.join(reactant_smas) + '>>' + '.'.join(product_smas)
    return unmapped_smarts

def get_compound_hash(
    smi: str, cpd_type: str = "Predicted", inchi_blocks: int = 1
) -> Tuple[str, Union[str, None]]:
    """Create a hash string for a given compound.

    This function generates an unique identifier for a compound, ensuring a
    normalized SMILES. The compound hash is generated by sanitizing and neutralizing the
    SMILES and then generating a hash from the sha1 method in the haslib.

    The hash is prepended with a character depending on the type. Default value is "C":
        1. Coreactant: "X"
        2. Target Compound: "T"
        3. Predicted Compound: "C"

    Parameters
    ----------
    smi : str
        The SMILES of the compound.
    cpd_type : str, optional
        The Compound Type, by default 'Predicted'.

    Returns
    -------
    Tuple[str, Union[str, None]]
        Compound hash, InChI-Key.
    """

    # The ID is generated from a hash of either the InChI key (partial) or SMILES
    # The InChI key is used if the SMILES does not contain '*'
    inchi_key = None

    if "*" not in smi:
        compound = AllChem.MolFromSmiles(smi, sanitize=False)
        try:
            inchi_key = AllChem.MolToInchiKey(compound)
            # Take the first part of the InChIKey as it contains structural
            # information only
            compound = inchi_key.rsplit("-", 3 - inchi_blocks)[0]
        except:
            compound = smi
    else:
        compound = smi

    # Create standard length hash string using hashlib module
    chash = hashlib.sha1(compound.encode("utf-8")).hexdigest()

    # Mark cofactors with an X at the beginning, targets with a T, all else with a C
    if cpd_type == "Coreactant":
        return "X" + chash, compound
    elif cpd_type == "Target Compound":
        return "T" + chash, inchi_key
    else:
        return "C" + chash, inchi_key
    
def get_reaction_hash(reactants, products):
    """Hashes reactant and product lists.

    Generates a unique ID for a given reaction for use in MongoDB.

    Parameters
    ----------
    reactants : List[StoichTuple]
        List of reactants.
    products : List[StoichTuple]
        List of products.

    Returns
    -------
        Reaction hash.
    """
    # Get text reaction to be hashed
    # this is a combination of two functions
    def to_str(half_rxn):
        return [f"({x[1]}) {x[0]}" for x in sorted(half_rxn)]
    reactants.sort()
    products.sort()
    text_ids_rxn = (
        " + ".join(to_str(reactants)) + " => " + " + ".join(to_str(products))
    )
    # Hash text reaction
    rhash = "R" + hashlib.sha256(text_ids_rxn.encode()).hexdigest()

    return rhash