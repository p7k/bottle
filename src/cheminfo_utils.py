import hashlib
from typing import Tuple, Union
import collections
import re
from rdkit import Chem
from rdkit.Chem import AllChem
from rdkit.Chem.MolStandardize import rdMolStandardize

StoichTuple = collections.namedtuple("StoichTuple", "c_id, stoich")

def standardize_mol(
        mol,
        max_tautomers = 1000,
        do_neutralize = True,
        do_find_parent = True,
        remove_stereo=False,
    ):

    if remove_stereo:
        Chem.rdmolops.RemoveStereochemistry(mol)

    # removeHs, disconnect metal atoms, normalize the molecule, reionize the molecule
    # Also checks valency, that mol is kekulizable
    mol = rdMolStandardize.Cleanup(mol)

    # if many fragments, get the "parent" (the actual mol we are interested in)
    if do_find_parent:
        mol = rdMolStandardize.FragmentParent(mol)

    if do_neutralize:
        mol = neutralize_charges(mol) # Remove charges on atoms matching common patterns

    # Enumerate tautomers and choose canonical one
    te = rdMolStandardize.TautomerEnumerator()
    te.SetMaxTautomers(max_tautomers)
    mol = te.Canonicalize(mol)
    
    return mol

def standardize_smiles(
        smiles,
        max_tautomers = 1000,
        do_neutralize = True,
        do_find_parent = True,
        remove_stereo=False,
        ):
    mol = Chem.MolFromSmiles(smiles)
    mol = standardize_mol(
        mol,
        max_tautomers=max_tautomers,
        do_neutralize=do_neutralize,
        do_find_parent=do_find_parent,
        remove_stereo=remove_stereo
    )
    return Chem.MolToSmiles(mol)

def standardize_smarts_rxn(
        smarts_rxn,
        max_tautomers = 1000,
        do_neutralize = True,
        do_find_parent = True,
        remove_stereo=False,
    ):
    '''
    Args
    ----
    smarts_rxn:str - SMARTS-encoded reaction, 'reactant.reactant>>product.product'
    '''
    std_smi = lambda smiles : standardize_smiles(smiles, max_tautomers, do_neutralize, do_find_parent, remove_stereo)

    rcts, pdts = [side.split('.') for side in smarts_rxn.split('>>')]
    rcts = [std_smi(r) for r in rcts]
    pdts = [std_smi(p) for p in pdts]
    return f"{'.'.join(rcts)}>>{'.'.join(pdts)}"

def clean_up_rhea_rxn(rxn_smarts):
    '''
    Args
    ----
    smarts_rxn:str - SMARTS-encoded reaction, 'reactant.reactant>>product.product'
    '''
    numbered_asterisks = r'\[\d+\*\]' # Numbered asterisks found in rhea 
    protons = r'(\.\[H\+\]|\[H\+\]\.)'

    rxn_smarts = re.sub(numbered_asterisks, '*', rxn_smarts) # De-number e.g., '[1*]' -> '*'
    rxn_smarts = re.sub(protons, '', rxn_smarts) # Remove protons

    return rxn_smarts


def get_compound_hash(
    smi: str, cpd_type: str = "Predicted", inchi_blocks: int = 1
) -> Tuple[str, Union[str, None]]:
    """Create a hash string for a given compound.

    This function generates an unique identifier for a compound, ensuring a
    normalized SMILES. The compound hash is generated by sanitizing and neutralizing the
    SMILES and then generating a hash from the sha1 method in the haslib.

    The hash is prepended with a character depending on the type. Default value is "C":
        1. Coreactant: "X"
        2. Target Compound: "T"
        3. Predicted Compound: "C"

    Parameters
    ----------
    smi : str
        The SMILES of the compound.
    cpd_type : str, optional
        The Compound Type, by default 'Predicted'.

    Returns
    -------
    Tuple[str, Union[str, None]]
        Compound hash, InChI-Key.
    """

    # The ID is generated from a hash of either the InChI key (partial) or SMILES
    # The InChI key is used if the SMILES does not contain '*'
    inchi_key = None

    if "*" not in smi:
        compound = AllChem.MolFromSmiles(smi, sanitize=False)
        try:
            inchi_key = AllChem.MolToInchiKey(compound)
            # Take the first part of the InChIKey as it contains structural
            # information only
            compound = inchi_key.rsplit("-", 3 - inchi_blocks)[0]
        except:
            compound = smi
    else:
        compound = smi

    # Create standard length hash string using hashlib module
    chash = hashlib.sha1(compound.encode("utf-8")).hexdigest()

    # Mark cofactors with an X at the beginning, targets with a T, all else with a C
    if cpd_type == "Coreactant":
        return "X" + chash, compound
    elif cpd_type == "Target Compound":
        return "T" + chash, inchi_key
    else:
        return "C" + chash, inchi_key
    
def get_reaction_hash(reactants, products):
    """Hashes reactant and product lists.

    Generates a unique ID for a given reaction for use in MongoDB.

    Parameters
    ----------
    reactants : List[StoichTuple]
        List of reactants.
    products : List[StoichTuple]
        List of products.

    Returns
    -------
        Reaction hash.
    """
    # Get text reaction to be hashed
    # this is a combination of two functions
    def to_str(half_rxn):
        return [f"({x[1]}) {x[0]}" for x in sorted(half_rxn)]
    reactants.sort()
    products.sort()
    text_ids_rxn = (
        " + ".join(to_str(reactants)) + " => " + " + ".join(to_str(products))
    )
    # Hash text reaction
    rhash = "R" + hashlib.sha256(text_ids_rxn.encode()).hexdigest()

    return rhash



def neutralize_charges(mol: Chem.rdchem.Mol) -> Chem.rdchem.Mol:
    """Neutralize all charges in an rdkit mol.

    Parameters
    ----------
    mol : rdkit.Chem.rdchem.Mol
        Molecule to neutralize.

    Returns
    -------
    mol : rdkit.Chem.rdchem.Mol
        Neutralized molecule.
    """
    patts = (
        ("[n+;H]", "n"), # Imidazoles
        ("[N+;!H0]", "N"), # Amines
        ("[$([O-]);!$([O-][#7])]", "O"), # Carboxylic acids and alcohols
        ("[S-;X1]", "S"), # Thiols
        ("[$([N-;X2]S(=O)=O)]", "N"), # Sulfonamides
        ("[$([N-;X2][C,N]=C)]", "N"), # Enamines
        ("[n-]", "[nH]"), # Tetrazoles
        ("[$([S-]=O)]", "S"), # Sulfoxides
        ("[$([N-]C=O)]", "N"), # Amides
    )

    reactions = [
        (AllChem.MolFromSmarts(x), AllChem.MolFromSmiles(y, False)) for x,y in patts
    ]

    for (reactant, product) in reactions:
        while mol.HasSubstructMatch(reactant):
            rms = AllChem.ReplaceSubstructs(mol, reactant, product)
            mol = rms[0]
    return mol

def smarts_to_sub_smiles(smarts):
    reactants, products = smarts.split(">>")
    reactants = reactants.split('.')
    products = products.split('.')
    return reactants, products

def sub_smiles_to_smarts(reactants, products):
    sma = ".".join(reactants) + '>>' + ".".join(products)
    return sma

# def postsanitize_smiles(smiles_list):
#     """Postsanitize smiles after running SMARTS.
#     :returns tautomer list of list of smiles"""
#     sanitized_list = []
#     tautomer_smarts = "[#7H1X3&a:1]:[#6&a:2]:[#7H0X2&a:3]>>[#7H0X2:1]:[#6:2]:[#7H1X3:3]"
#     pattern = r'\[\d+\*\]' # Pattern for integer labeled *'s as in rhea
#     for s in smiles_list:
#         s = re.sub(pattern, '*', s)
#         temp_mol = Chem.MolFromSmiles(s, sanitize=False)
#         temp_mol = Chem.RemoveHs(temp_mol, sanitize=False)
#         aromatic_bonds = [
#             i.GetIdx()
#             for i in temp_mol.GetBonds()
#             if i.GetBondType() == Chem.rdchem.BondType.AROMATIC
#         ]
#         for i in temp_mol.GetBonds():
#             if i.GetBondType() == Chem.rdchem.BondType.UNSPECIFIED:
#                 i.SetBondType(Chem.rdchem.BondType.SINGLE)
#         try:
#             Chem.SanitizeMol(temp_mol)
#             Chem.rdmolops.RemoveStereochemistry(temp_mol)
#             temp_smiles = Chem.MolToSmiles(temp_mol)
#         except Exception as msg:
#             if "Can't kekulize mol" in str(msg):
#                 pyrrole_indices = [
#                     i[0] for i in temp_mol.GetSubstructMatches(Chem.MolFromSmarts("n"))
#                 ]
#                 # indices to sanitize
#                 for s_i in pyrrole_indices:
#                     temp_mol = Chem.MolFromSmiles(s, sanitize=False)
#                     if temp_mol.GetAtomWithIdx(s_i).GetNumExplicitHs() == 0:
#                         temp_mol.GetAtomWithIdx(s_i).SetNumExplicitHs(1)
#                     elif temp_mol.GetAtomWithIdx(s_i).GetNumExplicitHs() == 1:
#                         temp_mol.GetAtomWithIdx(s_i).SetNumExplicitHs(0)
#                     try:
#                         Chem.SanitizeMol(temp_mol)
#                         processed_pyrrole_indices = [
#                             i[0]
#                             for i in temp_mol.GetSubstructMatches(
#                                 Chem.MolFromSmarts("n")
#                             )
#                         ]
#                         processed_aromatic_bonds = [
#                             i.GetIdx()
#                             for i in temp_mol.GetBonds()
#                             if i.GetBondType() == Chem.rdchem.BondType.AROMATIC
#                         ]
#                         if (
#                             processed_pyrrole_indices != pyrrole_indices
#                             or aromatic_bonds != processed_aromatic_bonds
#                         ):
#                             continue
#                         Chem.rdmolops.RemoveStereochemistry(temp_mol)
#                         temp_smiles = Chem.MolToSmiles(temp_mol)
#                         break
#                     except:
#                         continue
#                 if "temp_smiles" not in vars():
#                     Chem.rdmolops.RemoveStereochemistry(temp_mol)
#                     temp_smiles = Chem.MolToSmiles(temp_mol)
#                     sanitized_list.append([temp_smiles])
#                     continue
#             else:
#                 Chem.rdmolops.RemoveStereochemistry(temp_mol)
#                 temp_smiles = Chem.MolToSmiles(temp_mol)
#                 sanitized_list.append([temp_smiles])
#                 continue
#         rxn = AllChem.ReactionFromSmarts(tautomer_smarts)
#         try:
#             tautomer_mols = rxn.RunReactants((Chem.MolFromSmiles(temp_smiles),))
#         except:
#             try:
#                 tautomer_mols = rxn.RunReactants(
#                     (Chem.MolFromSmiles(temp_smiles, sanitize=False),)
#                 )
#             except:
#                 continue
#         tautomer_smiles = [Chem.MolToSmiles(m[0]) for m in tautomer_mols]
#         sanitized_list.append(sorted(set(tautomer_smiles + [temp_smiles])))
#     return list(itertools.product(*sanitized_list))

# def sanitize(list_of_smiles):
#     '''
#     Remove stereochem and canonicalize
#     a list of smiles
#     '''
#     sanitized_smiles = []
#     for elt in list_of_smiles:
#         temp_mol = Chem.MolFromSmiles(elt)
#         if temp_mol:
#             Chem.rdmolops.RemoveStereochemistry(temp_mol)
#             sanitized_smiles.append(Chem.MolToSmiles(temp_mol))
#         else:
#             sanitized_smiles.append(None)
#     return sanitized_smiles

# def rxn_entry_to_smarts(rxn_entry):
#     '''
#     Convert our standard rxn json
#     entry into a reaction smarts
#     '''
#     reactants = sanitize(list(rxn_entry[0].values()))
#     products = sanitize(list(rxn_entry[1].values()))
#     sma = ".".join(reactants) + ">>" + ".".join(products)
#     return sma

if __name__ == '__main__':
    test_rhea_clean = [
        ('CC[H+]CC>>CC[H+]CC', 'CC[H+]CC>>CC[H+]CC'),
        ('CC.[H+]>>CC', 'CC>>CC'),
        ('[H+].CC>>CC', 'CC>>CC'),
        ('CC.[H+].CC>>CO', 'CC.CC>>CO'),
        ('CC[1*]', 'CC*'),
        ('C[1*]C', 'C*C'),
        ('[13*]', '*'),
        ('*', '*')
    ]

    for start, target in test_rhea_clean:
        assert target == clean_up_rhea_rxn(start)

    import pandas as pd
    rhea_smarts = pd.read_csv('/home/stef/bottle/data/mapping/rhea-reaction-smiles.tsv', '\t', header=None)
    rhea_smarts.columns = ["rhea_id", "smarts"]
    bad_smarts = []
    for i, row in rhea_smarts.iterrows():
        try:
            standardize_smarts_rxn(row['smarts'])
        except:
            bad_smarts.append(row['smarts'])

    print(f"Standardized {(i+1 - len(bad_smarts)) / (i+1)} SMARTS. Bad smarts:")
    for elt in bad_smarts:
        print(elt)


    