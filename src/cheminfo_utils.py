import hashlib
from typing import Tuple, Union
import collections
import re
from rdkit import Chem
from rdkit.Chem import AllChem
from rdkit.Chem.MolStandardize import rdMolStandardize

StoichTuple = collections.namedtuple("StoichTuple", "c_id, stoich")

def _handle_kwargs(**kwargs):
    default_kwargs = {
        'do_canon_taut':False,
        'do_neutralize':True,
        'do_find_parent':True,
        'do_remove_stereo':True,
        'max_tautomers':1000,
    }
    filtered_kwargs = {k : v for k, v in kwargs.items() if k in default_kwargs}
    default_kwargs.update(filtered_kwargs)
    return default_kwargs


def standardize_mol(mol, **kwargs):
    kwargs = _handle_kwargs(**kwargs)

    if kwargs['do_remove_stereo']:
        Chem.rdmolops.RemoveStereochemistry(mol)

    # removeHs, disconnect metal atoms, normalize the molecule, reionize the molecule
    # Also checks valency, that mol is kekulizable
    mol = rdMolStandardize.Cleanup(mol)

    # if many fragments, get the "parent" (the actual mol we are interested in)
    if kwargs['do_find_parent']:
        mol = rdMolStandardize.FragmentParent(mol)

    if kwargs['do_neutralize']:
        mol = neutralize_charges(mol) # Remove charges on atoms matching common patterns

    # Enumerate tautomers and choose canonical one
    if kwargs['do_canon_taut']:
        te = rdMolStandardize.TautomerEnumerator()
        te.SetMaxTautomers(kwargs['max_tautomers'])
        mol = te.Canonicalize(mol)
    
    return mol

def standardize_smiles(smiles, **kwargs):
    kwargs = _handle_kwargs(**kwargs)
    mol = Chem.MolFromSmiles(smiles)
    mol = standardize_mol(
        mol,
        **kwargs
    )
    return Chem.MolToSmiles(mol)

def standardize_smarts_rxn(smarts_rxn, **kwargs):
    kwargs = _handle_kwargs(**kwargs)
    '''
    Args
    ----
    smarts_rxn:str - SMARTS-encoded reaction, 'reactant.reactant>>product.product'
    '''

    rcts, pdts = [side.split('.') for side in smarts_rxn.split('>>')]
    rcts = [standardize_smiles(r, **kwargs) for r in rcts]
    pdts = [standardize_smiles(p, **kwargs) for p in pdts]
    return f"{'.'.join(rcts)}>>{'.'.join(pdts)}"

def clean_up_rhea_rxn(rxn_smarts):
    '''
    Args
    ----
    smarts_rxn:str - SMARTS-encoded reaction, 'reactant.reactant>>product.product'
    '''
    numbered_asterisks = r'\[\d+\*\]' # Numbered asterisks found in rhea 
    protons = r'(\.\[H\+\]|\[H\+\]\.)'

    rxn_smarts = re.sub(numbered_asterisks, '*', rxn_smarts) # De-number e.g., '[1*]' -> '*'
    rxn_smarts = re.sub(protons, '', rxn_smarts) # Remove protons

    return rxn_smarts


def get_compound_hash(
    smi: str, inchi_blocks: int = 1
) -> Tuple[str, Union[str, None]]:
    """Create a hash string for a given compound.

    This function generates an unique identifier for a compound, ensuring a
    normalized SMILES. The compound hash is generated by sanitizing and neutralizing the
    SMILES and then generating a hash from the sha1 method in the hashlib.

    Parameters
    ----------
    smi : str
        The SMILES of the compound.

    Returns
    -------
    Tuple[str, Union[str, None]]
        Compound hash, InChI-Key.
    """

    # The ID is generated from a hash of either the InChI key (partial) or SMILES
    # The InChI key is used if the SMILES does not contain '*'
    inchi_key = None

    if "*" not in smi:
        compound = AllChem.MolFromSmiles(smi)
        try:
            inchi_key = AllChem.MolToInchiKey(compound)
            # Take the first part of the InChIKey as it contains structural
            # information only
            compound = inchi_key.rsplit("-", 3 - inchi_blocks)[0]
        except:
            compound = smi
    else:
        compound = smi

    # Create standard length hash string using hashlib module
    chash = hashlib.sha1(compound.encode("utf-8")).hexdigest()

    # Mark cofactors with an X at the beginning, targets with a T, all else with a C
    return "C" + chash, inchi_key
    
def get_reaction_hash(reactants, products):
    """Hashes reactant and product lists.

    Generates a unique ID for a given reaction for use in MongoDB.

    Parameters
    ----------
    reactants : List[StoichTuple]
        List of reactants.
    products : List[StoichTuple]
        List of products.

    Returns
    -------
        Reaction hash.
    """
    # Get text reaction to be hashed
    # this is a combination of two functions
    def to_str(half_rxn):
        return [f"({x[1]}) {x[0]}" for x in sorted(half_rxn)]
    reactants.sort()
    products.sort()
    text_ids_rxn = (
        " + ".join(to_str(reactants)) + " => " + " + ".join(to_str(products))
    )
    # Hash text reaction
    rhash = "R" + hashlib.sha256(text_ids_rxn.encode()).hexdigest()

    return rhash

def neutralize_charges(mol: Chem.rdchem.Mol) -> Chem.rdchem.Mol:
    """Neutralize all charges in an rdkit mol.

    Parameters
    ----------
    mol : rdkit.Chem.rdchem.Mol
        Molecule to neutralize.

    Returns
    -------
    mol : rdkit.Chem.rdchem.Mol
        Neutralized molecule.
    """
    patts = (
        ("[n+;H]", "n"), # Imidazoles
        ("[N+;!H0]", "N"), # Amines
        ("[$([O-]);!$([O-][#7])]", "O"), # Carboxylic acids and alcohols
        ("[S-;X1]", "S"), # Thiols
        ("[$([N-;X2]S(=O)=O)]", "N"), # Sulfonamides
        ("[$([N-;X2][C,N]=C)]", "N"), # Enamines
        ("[n-]", "[nH]"), # Tetrazoles
        ("[$([S-]=O)]", "S"), # Sulfoxides
        ("[$([N-]C=O)]", "N"), # Amides
    )

    reactions = [
        (AllChem.MolFromSmarts(x), AllChem.MolFromSmiles(y, False)) for x,y in patts
    ]

    for (reactant, product) in reactions:
        while mol.HasSubstructMatch(reactant):
            rms = AllChem.ReplaceSubstructs(mol, reactant, product)
            mol = rms[0]
    return mol

def tautomer_expand(molecule, k):
    '''
    Returns top k tautomers of given molecule in the
    format provided.

    Args
    ----
    molecule:Mol | str
    k:int

    Returns
    --------
    tautomers:List[Mol] | List[str]
    '''
    if type(molecule) is str:
        molecule = Chem.MolFromSmiles(molecule)
        mode = 'str'
    elif type(molecule) is Chem.Mol:
        mode = 'mol'
    
    enumerator = rdMolStandardize.TautomerEnumerator()
    tauts = enumerator.Enumerate(molecule)
    taut_score = [(taut, enumerator.ScoreTautomer(taut)) for taut in tauts]
    taut_score = sorted(taut_score, key=lambda x : x[1], reverse=True) # Sort by score
    
    # Separate out ties
    best_score = taut_score[0][1]
    arg_last_tie = 0
    for i, (_, score) in enumerate(taut_score):
        if score == best_score:
            arg_last_tie = i
        else:
            break

    tauts, _ = zip(*taut_score)
    ties, rest = tauts[:arg_last_tie + 1], list(tauts[arg_last_tie + 1 :])
    
    ties = sorted(ties, key=lambda x : Chem.MolToSmiles(x), reverse=False) # Tie goes to lexicographically lesser SMILES
    tauts = (ties + rest)[:k] # Take top k

    if mode == 'mol':
        return tauts
    elif mode == 'str':
        return [Chem.MolToSmiles(taut) for taut in tauts]

if __name__ == '__main__':
    test_rhea_clean = [
        ('CC[H+]CC>>CC[H+]CC', 'CC[H+]CC>>CC[H+]CC'),
        ('CC.[H+]>>CC', 'CC>>CC'),
        ('[H+].CC>>CC', 'CC>>CC'),
        ('CC.[H+].CC>>CO', 'CC.CC>>CO'),
        ('CC[1*]', 'CC*'),
        ('C[1*]C', 'C*C'),
        ('[13*]', '*'),
        ('*', '*')
    ]

    for start, target in test_rhea_clean:
        assert target == clean_up_rhea_rxn(start)

    smi1 = "C(CO)(COP([O-])(=O)[O-])=O"
    smi2 = "[H]C(=O)[C@H](O)COP([O-])([O-])=O"
    sma = f"{smi1}>>{smi2}"
    assert(standardize_smiles(smi1, do_canon_taut=True) == standardize_smiles(smi2, do_canon_taut=True))
    assert(standardize_smiles(smi1) != standardize_smiles(smi2))
    standardize_smarts_rxn(sma)

    